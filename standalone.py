#!/usr/bin/python2.7
from qgis.core import *
from qgis import utils
from qgis import *
from PyQt4.QtCore import *
import io, os, sys, collections, random, tempfile

########
# INFO #
########
def standalone_version():
    return "0.1.1"

#################
# GET OPERATION #
#################
operation = sys.argv[1]




app = QgsApplication([],False, None)
app.setPrefixPath("/usr", True)
# load providers
app.initQgis()

compiler='cGPSmapper'

#############
# FUNCTIONS #
#############

def WKBType_to_GeometryType(WKBType):
    if WKBType==QGis.WKBUnknown:
        return QGis.UnknownGeometry
    if WKBType==QGis.WKBPoint:
        return QGis.Point
    if WKBType==QGis.WKBLineString :
        return QGis.Line
    if WKBType==QGis.WKBPolygon:
        return QGis.Polygon
    if WKBType==QGis.WKBMultiPoint :
        return QGis.Point
    if WKBType==QGis.WKBMultiLineString :
        return QGis.Line
    if WKBType==QGis.WKBMultiPolygon:
        return QGis.Polygon
    if WKBType==QGis.WKBMultiPolygon:
        return QGis.NoGeometry


def default_mp_header():
    default_header = collections.OrderedDict()
    polishexporter_ver=standalone_version()
    default_header = {}
    default_header['ID'] = random.randint(10000000,99999999)
    default_header['Name']='python exporter map'
    default_header['LBLcoding']=6
    default_header['Codepage']=1252
    default_header['Datum']='W84'
    default_header['Transparent']='N'
    default_header['MG']='N'
    default_header['Numbering']='N'
    default_header['Routing']='N'
    default_header['ProductCode']=1
    default_header['Copyright']='map generated by polish exporter '+polishexporter_ver    
    default_header['Elevation']='M'
    default_header['POIIndex']='N'
    default_header['POINumberFirst']='Y'
    default_header['POIZipFirst']='Y'
    default_header['CountryName']=''
    default_header['RegionName']=''
    default_header['TreSize']=1500
    default_header['TreMargin']=0.00000
    default_header['RgnLimit']=1024
    default_header['SimplifyLevel']=1
    default_header['Preprocess']='F'   

    default_header['Levels']=5
    default_header['Level0']=24
    default_header['Level1']=22
    default_header['Level2']=20
    default_header['Level3']=17
    default_header['Level4']=15
    default_header['Zoom0']=0
    default_header['Zoom1']=1
    default_header['Zoom2']=2
    default_header['Zoom3']=3
    default_header['Zoom4']=4

    default_header['Preview']='N'
    default_header['DrawPriority']=25
    default_header['Marine']='N'
    default_header['LeftSideTraffic']='N'
    default_header['NT']='N' 
    default_header['PolygonEvaluate']='Y' 
    
    return default_header

def attribute_odict(GeometryType):
    default_attributes_odict=None
    if GeometryType==QGis.Point:
        default_attributes_odict = collections.OrderedDict()
        #Name in pdf = [default value,data type, attribute name for shp, required for polish bool]
        default_attributes_odict['id'] =[None,QVariant.Int,'id',False]
        default_attributes_odict['Img_id'] = [None,QVariant.Int,'MP_MAP_ID',False]
        default_attributes_odict['Feature_id'] =[None,QVariant.Int,'MP_FEAT_ID',False]
        default_attributes_odict['Type'] = ['0x00',QVariant.String,'MP_TYPE',True]
        default_attributes_odict['Marine'] = ['N',QVariant.String,'MP_MARINE',False]
        default_attributes_odict['City'] = ['N',QVariant.String,'MP_CITY',False]
        default_attributes_odict['Label'] = [None,QVariant.String,'MP_LBL',False]
        default_attributes_odict['EndLevel'] = [None,QVariant.Int,'MP_BIT_LVL',False]
        default_attributes_odict['DataLevel'] = [0,QVariant.Int,'MP_DTA_LVL',True]
        default_attributes_odict['StreetDesc'] = [None,QVariant.String,'MP_SDC',False]
        default_attributes_odict['HouseNumber'] = [None,QVariant.Int,'MP_HSNO',False]
        default_attributes_odict['OvernightParking'] = ['N',QVariant.String,'MP_ONPRK',False]
        default_attributes_odict['Highway'] = [None,QVariant.String,'MP_HWY',False]
        default_attributes_odict['CityName'] = [None,QVariant.String,'MP_CTYNM',False]
        default_attributes_odict['RegionName'] = [None,QVariant.String,'MP_RGNNM',False]
        default_attributes_odict['CountryName'] = [None,QVariant.String,'MP_CNTNM',False]
        default_attributes_odict['Zip'] = [None,QVariant.String,'MP_ZIP',False]
        default_attributes_odict['Exit'] = [None,QVariant.String,'MP_EXIT',False]
        
    if GeometryType==QGis.Polygon:
        default_attributes_odict = collections.OrderedDict()
        default_attributes_odict['id'] =[None,QVariant.Int,'id',False]
        default_attributes_odict['Img_id'] = [None,QVariant.Int,'MP_MAP_ID',False]
        default_attributes_odict['Feature_id'] =[None,QVariant.Int,'MP_FEAT_ID',False]
        default_attributes_odict['Type'] = ['0x00',QVariant.String,'MP_TYPE',True]
        default_attributes_odict['Marine'] = ['N',QVariant.String,'MP_MARINE',False]
        default_attributes_odict['Label'] = [None,QVariant.String,'MP_LBL',False]
        default_attributes_odict['EndLevel'] = [None,QVariant.Int,'MP_BIT_LVL',False]
        default_attributes_odict['Background'] = ['N',QVariant.String,'MP_BKGRND',False]
        default_attributes_odict['DataLevel'] = [0,QVariant.Int,'MP_DTA_LVL',True]

    if GeometryType==QGis.Line:
        default_attributes_odict = collections.OrderedDict()
        default_attributes_odict['id'] =[None,QVariant.Int,'id',False]
        default_attributes_odict['Img_id'] = [None,QVariant.Int,'MP_MAP_ID',False]
        default_attributes_odict['Feature_id'] =[None,QVariant.Int,'MP_FEAT_ID',False]
        default_attributes_odict['Type'] = ['0x00',QVariant.String,'MP_TYPE',True]
        default_attributes_odict['Marine'] = ['N',QVariant.String,'MP_MARINE',False]
        
        default_attributes_odict['Label'] = [None,QVariant.String,'MP_LBL',False]
        default_attributes_odict['Label2'] = [None,QVariant.String,'MP_LBL2',False]
        default_attributes_odict['EndLevel'] = [None,QVariant.Int,'MP_BIT_LVL',False]
        default_attributes_odict['DataLevel'] = [0,QVariant.Int,'MP_DTA_LVL',True]
        default_attributes_odict['StreetDesc'] = [None,QVariant.String,'MP_ST_DSC',False]
        default_attributes_odict['DirIndicator'] = [0,QVariant.Int,'MP_DIR_IND',False]
        default_attributes_odict['CityName'] = [None,QVariant.String,'MP_CTYNM',False]
        default_attributes_odict['RegionName'] = [None,QVariant.String,'MP_RGNNM',False]
        default_attributes_odict['CountryName'] = [None,QVariant.String,'MP_CNTNM',False]
        default_attributes_odict['Zip'] = [None,QVariant.String,'MP_ZIP',False]
        
        #Routing specific
        default_attributes_odict['RoadID'] = [None,QVariant.Int,'MP_ROAD_ID',False]
        for n in range(1, 60):
            default_attributes_odict['Numbers'+str(n)]= [None,QVariant.String,'MP_NUM'+str(n),False]
        default_attributes_odict['Routeparam'] = ['3,4,0,0,0,0,0,0,0,0,0,0',QVariant.String,'MP_ROUTE',False]
        default_attributes_odict['NodIDs']=[None,QVariant.String,'MP_NODES',False]#eg '1,0,1002,0|2,1,1003,0'
    
    if GeometryType==QGis.UnknownGeometry:
        raise ValueError('Cannot build attribute for feature of Unknown Geometry',GeometryType)
        
    if GeometryType==QGis.NoGeometry:
        raise ValueError('Cannot build attribute for feature with No Geometry',GeometryType)
    
    if default_attributes_odict==None:
        raise ValueError('Unknown GeometryType',QGisType)
    return default_attributes_odict
    
    
def bit_level(file_header_dict,bit_val):
    #returns the level# associated with a given bit level value
    BIT_LEVEL_DICT = {}
    for key in file_header_dict:
        if key.startswith("Level"):
            if key!="Levels":
                BIT_LEVEL_DICT[int(file_header_dict[key])]=int(str(key[5:]))
    rev_BIT_LEVEL_DICT = {v:k for k, v in BIT_LEVEL_DICT.items()}
    try:
        output=BIT_LEVEL_DICT[int(bit_val)]
    except:
        print BIT_LEVEL_DICT
        print "bit_val is:"+str(bit_val)
        print "WARNING INVALID MP_BIT_VAL SETTING DATA LEVEL 0"
        output=0
    return output
    
def rev_bit_level(file_header_dict,level_val):
    #returns the bit level associated with a given level#
    BIT_LEVEL_DICT = {}
    for key in file_header_dict:
        if key.startswith("Level"):
            if key!="Levels":
                BIT_LEVEL_DICT[file_header_dict[key]]=str(key[5:])
    rev_BIT_LEVEL_DICT = {v:k for k, v in BIT_LEVEL_DICT.items()}
    return rev_BIT_LEVEL_DICT[level_val]
##############
# OPERATIONS #
##############
if operation == 'export':
    
    
    input_files_string = sys.argv[2]
    output_file = sys.argv[3]
    input_header_string = sys.argv[4]
    
    
    #Build header dictionary
    #Header values can be altered with a template file optional argument
    
    #Create default header
    default_header_odict=default_mp_header()
    
    
    #Create current mp header
    
    input_header_list=input_header_string.split(";")
    input_header_dict = {}
    for input_header_item in input_header_list:
        split_input_header_item=input_header_item.split("=")
        header_key=split_input_header_item[0]
        header_val=split_input_header_item[1]
        input_header_dict[header_key]=header_val
    
    file_header_odict = collections.OrderedDict()
    for header_key in default_mp_header():
        if header_key in input_header_dict:
            file_header_odict[header_key]=input_header_dict[header_key]
        else:
            file_header_odict[header_key]=default_header_odict[header_key]
        
        
        
        
    #polish_temp_file=os.path.join(tempfile.gettempdir(),"polish_temp_file.mp")
    #polish_temp_file=os.path.join("/home/richard/Documents/GIS/INDIA/DEM/POLISH","polish_temp_file.mp")
    
    
    
    input_files_list=input_files_string.split(";")    
    polish_temp_file = output_file
    with io.open(polish_temp_file, 'w',1,None,None,'\r\n') as polish_file:
        #Write header to file
        #print 'writing '+output_file
#       #polish_file.write(r';')# generated by Mr Purples pyQGIS polish exporter '+str(myver())+u'\n')
        polish_file.write(u'[IMG ID]\n')
        for header_key in default_mp_header():
            polish_string= str(header_key)+"="+str(file_header_odict[header_key]) 
            polish_file.write(unicode(polish_string).rstrip()+'\n')
        polish_file.write(u'[END-IMG ID]\n')
        polish_file.write(u'\n')
        
            
        #OUTPUT DATA

        #print input_files_list
        for input_file in input_files_list:
            #input_file = "/home/richard/Documents/GIS/INDIA/DEM/TYPED_SHAPES/0x22_n27_e068.shp"
            input_layer = QgsVectorLayer(input_file, "input layer", "ogr")
            layer_dp=input_layer.dataProvider()
            crsSrc = layer_dp.crs()
            crsDest = QgsCoordinateReferenceSystem(4326)  # WGS84
            xform = QgsCoordinateTransform(crsSrc, crsDest)
            
            #GET ATTRIBUTE IDX VALUES FROM LAYER
            feature_attribute_odict=collections.OrderedDict()
            #Determine kind from layer type
            layer_WkbType=input_layer.dataProvider().geometryType() 
            #http://qgis.org/api/group__core.html#ga8da456870e1caec209d8ba7502cceff7
            layer_GeometryType=WKBType_to_GeometryType(layer_WkbType)
            #http://qgis.org/api/group__core.html#ga09947eb19394302eeeed44d3e81dd74b
            
            default_attributes=attribute_odict(layer_GeometryType)
            mp_attr_name_list=[]
            mp_attr_idx_list=[]
            for default_attribute in default_attributes:
                mp_attr_name_list.append(default_attributes[default_attribute][2])
                mp_attr_idx_list.append(input_layer.fieldNameIndex(default_attributes[default_attribute][2]))
            #print mp_attr_idx_list
            #raise ValueError('THIS IS MY DEBUG RAISE LINE')
            
            #QgsMapLayerRegistry.instance().addMapLayer(input_layer)
            #print str(input_layer.featureCount())
            #print input_layer.dataProvider().crs().authid()
            layer=input_layer
            for feature in input_layer.getFeatures():

                #################################################################

                default_feature_attributes_odict=attribute_odict(layer_GeometryType)
                feature_attributes_odict = collections.OrderedDict()
                MP_NAME_SET=False
               
                for default_feature_attribute in default_feature_attributes_odict:
                    attribute_name=default_feature_attributes_odict[default_feature_attribute][2]
                    layer_attribute_idx=layer.fieldNameIndex(attribute_name)
                    if layer_attribute_idx>=0:
                        if str(feature.attributes()[layer_attribute_idx])=='NULL':
                            feature_attributes_odict[default_feature_attribute]=None
                        else:
                            if feature.attributes()[layer_attribute_idx]==default_feature_attributes_odict[default_feature_attribute][0]:
                                pass
                            feature_attributes_odict[default_feature_attribute] = feature.attributes()[layer_attribute_idx]
                    else:
                        if default_feature_attributes_odict[default_feature_attribute][3]:
                            feature_attributes_odict[default_feature_attribute] = default_feature_attributes_odict[default_feature_attribute][0]
                        else:
                            feature_attributes_odict[default_feature_attribute] = None
                    MP_NAMElayer_attribute_idx=layer.fieldNameIndex("MP_NAME")
                    if MP_NAMElayer_attribute_idx>=0:
                        #raise ValueError('FOUND MP_NAME ATTR')
                        MP_LBL_layer_attribute_idx=layer.fieldNameIndex("MP_LBL")
                        if MP_LBL_layer_attribute_idx<=0:
                            #raise ValueError('HAVE MP_NAME ATTR & NO MP_LBL ATTR')
                            #layer_attribute_idx=layer.fieldNameIndex("MP_NAME")
                            MP_LBL_ATTR=str(feature.attributes()[MP_NAMElayer_attribute_idx])
                            #raise ValueError('MP_LBLs contained in attribute called'+MP_LBL_ATTR)
                            if MP_LBL_ATTR =='NULL':
                                #raise ValueError('EMPTY MP_NAME ATTR')
                                MP_LBL_val=None
                                MP_NAME_SET=True
                            else:
                                MP_LBL_ATTR_idx=layer.fieldNameIndex(MP_LBL_ATTR)
                                if MP_LBL_ATTR_idx>=0:
                                    MP_LBL_val=str(feature.attributes()[MP_LBL_ATTR_idx])
                                    MP_NAME_SET=True
                                    if MP_LBL_val=="NULL":
                                        MP_LBL_val=None
                                    else:
                                        pass
                                        #raise ValueError('FOUND ACTUAL EXTANT MP_NAME ATTR'+MP_LBL_val)
                if MP_NAME_SET:
                    #print feature_attributes_odict
                    temp_feature_attributes_odict = collections.OrderedDict()
                    for key in feature_attributes_odict:
                        if key == "Label":
                            temp_feature_attributes_odict[key]=MP_LBL_val
                        else:
                            temp_feature_attributes_odict[key]=feature_attributes_odict[key]
                    Feature_attributes_odict=temp_feature_attributes_odict
                    temp_feature_attributes_odict=None

                
                ##########################################
                QGisType=layer_GeometryType
                if QGisType == QGis.Point:
                    outputtype = '[POI]'
                if QGisType == QGis.Line:
                    outputtype = '[POLYLINE]'
                if QGisType == QGis.Polygon:
                    outputtype = '[POLYGON]'
                polish_file.write(u''+outputtype+'\n')
                
                
                for Feature_attribute in Feature_attributes_odict:
                    attr_name=str(Feature_attribute)
                    #print Feature_attributes_odict[attr_name]
                    attr_val=Feature_attributes_odict[attr_name]
                    if attr_name=="EndLevel": #Convert to level rather than bit thingy
                        if attr_val is not None:
                            attr_val=bit_level(file_header_odict,attr_val)
                            polish_file.write(attr_name+u'='+str(attr_val)+'\n')
                            attr_val=None

                    if attr_name=="DataLevel": #Convert to level rather than bit thingy
                        DATA_LVL=int(attr_val)
                        attr_val=None
                    if attr_name[:7]=='Numbers':
                        pass
                        #multi line output but it will go as default
                    if attr_name=='NodIDs':
                        pass
                        #split the string on | for multi line output then set attr_val to None
                        if attr_val is not None:
                            nod_string_list=attr_val.split("|")
                            for nod_string in nod_string_list:
                                Nod_id_string="Nod"+str(nod_string.split(",")[0])
                                Nod_val_string=",".join(nod_string.split(",")[-(len(nod_string.split(","))-1):])
                                polish_file.write(Nod_id_string+u'='+Nod_val_string+'\n')
                                attr_val=None
                            
                    if attr_name=='id':
                        attr_val=None
                    if attr_name=='Img_id':
                        attr_val=None
                    if attr_name=='Feature_id':
                        attr_val=None
                    if attr_name=='Type':
                        if compiler=="MapTk":
                            attr_val=attr_val.lower()
                        else:
                            pass
                        if attr_val=="0x0":
                            print "WARNING: Type cannot be 0x0"
                            print Feature_attributes_odict
                    if attr_val==attribute_odict(QGisType)[attr_name][0]:
                        attr_val=None
                        
                    if attr_val is not None:
                        polish_file.write(str(Feature_attribute)+u'='+str(attr_val)+'\n')
                


                datalinesgeoms=[]
                datalinesgeom=[]
                geom=feature.geometry()
                Feature_GeometryType=geom.type()
                if geom.type() == QGis.Point:
                    if geom.isMultipart():
                        for geomprime in geom.asMultiPoint():
                            datalinegeom=[]
                            datalinegeom.append(geomprime)
                            datalinesgeom=[]
                            datalinesgeom.append(datalinegeom)
                            datalinesgeoms.append(datalinesgeom)
                    else:
                        datalinegeom=[]
                        datalinegeom.append(geom.asPoint())
                        datalinesgeom=[]
                        datalinesgeom.append(datalinegeom)
                        datalinesgeoms.append(datalinesgeom)
                if geom.type() == QGis.Line:
                    if geom.isMultipart():
                        datalinesgeom=geom.asMultiPolyline()
                        datalinesgeoms.append(datalinesgeom)
                    else:
                        datalinesgeom=[]
                        datalinesgeom.append(geom.asPolyline())
                        datalinesgeoms.append(datalinesgeom)
                if geom.type() == QGis.Polygon:
                    if geom.isMultipart():
                        for datalinesgeom in geom.asMultiPolygon():
                            datalinesgeoms.append(datalinesgeom)
                    else:
                        datalinesgeom=geom.asPolygon()
                        datalinesgeoms.append(datalinesgeom)

                #if compiler=="cGPSmapper":
                #    data_decimal_places=12
                #else:
                data_decimal_places=5
                    
                for datalinesgeom in datalinesgeoms:
                    for datalinegeom in datalinesgeom:
                        firstpoint=True 
                        Datastring=""
                        for myQgsPoint in datalinegeom:
                            newQgsPoint=xform.transform(myQgsPoint)
                            if firstpoint:
                                firstpoint=False
                                Datastring=Datastring+'Data'+str(DATA_LVL)+'=('+Datastring
                            else:
                                Datastring=Datastring+',('
                            Datastring=Datastring+("{0:."+str(data_decimal_places)+"f}").format(newQgsPoint.y())+','+("{0:."+str(data_decimal_places)+"f}").format(newQgsPoint.x())+')'
                        polish_file.write(u''+Datastring+'\n')
                        polish_file.write(u'[END]\n\n')    
            input_layer=None



#print "hello"

app.exitQgis()
app.exit()
